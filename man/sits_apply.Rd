% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sits_apply.R
\name{sits_apply}
\alias{sits_apply}
\alias{sits_apply.sits}
\alias{sits_apply.raster_cube}
\alias{sits_apply.derived_cube}
\alias{sits_apply.default}
\title{Apply a function on a set of time series}
\usage{
sits_apply(data, ...)

\method{sits_apply}{sits}(data, ...)

\method{sits_apply}{raster_cube}(
  data,
  ...,
  window_size = 3L,
  memsize = 4L,
  multicores = 2L,
  normalized = TRUE,
  output_dir,
  progress = TRUE
)

\method{sits_apply}{derived_cube}(data, ...)

\method{sits_apply}{default}(data, ...)
}
\arguments{
\item{data}{Valid sits tibble or cube}

\item{...}{Named expressions to be evaluated (see details).}

\item{window_size}{An odd number representing the size of the
sliding window of sits kernel functions
used in expressions (for a list of supported
kernel functions, please see details).}

\item{memsize}{Memory available for classification (in GB).}

\item{multicores}{Number of cores to be used for classification.}

\item{normalized}{Does the expression produces a normalized band?}

\item{output_dir}{Directory where files will be saved.}

\item{progress}{Show progress bar?}
}
\value{
A sits tibble or a sits cube with new bands, produced
        according to the requested expression.
}
\description{
Apply a named expression to a sits cube or a sits tibble
to be evaluated and generate new bands (indices). In the case of sits
cubes, it creates a new band in \code{output_dir}.
}
\note{
The main \code{sits} classification workflow has the following steps:
\enumerate{
     \item{\code{\link[sits]{sits_cube}}: selects a ARD image collection from
         a cloud provider.}
     \item{\code{\link[sits]{sits_cube_copy}}: copies an ARD image collection
         from a cloud provider to a local directory for faster processing.}
     \item{\code{\link[sits]{sits_regularize}}: create a regular data cube
         from an ARD image collection.}
     \item{\code{\link[sits]{sits_apply}}: create new indices by combining
         bands of a  regular data cube (optional).}
     \item{\code{\link[sits]{sits_get_data}}: extract time series
         from a regular data cube based on user-provided labelled samples.}
     \item{\code{\link[sits]{sits_train}}: train a machine learning
         model based on image time series.}
     \item{\code{\link[sits]{sits_classify}}: classify a data cube
         using a machine learning model and obtain a probability cube.}
     \item{\code{\link[sits]{sits_smooth}}: post-process a probability cube
         using a spatial smoother to remove outliers and
         increase spatial consistency.}
     \item{\code{\link[sits]{sits_label_classification}}: produce a
         classified map by selecting the label with the highest probability
         from a smoothed cube.}
}

\code{sits_apply()} allows any valid R expression to compute new bands.
Use R syntax to pass an expression to this function.
Besides arithmetic operators, you can use virtually any R function
that can be applied to elements of a matrix (functions that are
unaware of matrix sizes, e.g. \code{sqrt()}, \code{sin()},
\code{log()}).

Examples of valid expressions:
\enumerate{
\item \code{NDVI = (B08 - B04/(B08 + B04))} for Sentinel-2 images.
\item \code{EVI = 2.5 * (B05 – B04) / (B05 + 6 * B04 – 7.5 * B02 + 1)} for
Landsat-8/9 images.
\item \code{VV_VH_RATIO = VH/VV} for Sentinel-1 images. In this case,
set the \code{normalized} parameter to FALSE.
\item \code{VV_DB = 10 * log10(VV)} to convert Sentinel-1 RTC images
available in Planetary Computer to decibels. Also, set the
\code{normalized} parameter to FALSE.
}

\code{sits_apply()} accepts a predefined set of kernel functions
(see below) that can be applied to pixels considering its
neighborhood. \code{sits_apply()} considers a neighborhood of a
pixel as a set of pixels equidistant to it (including itself).
This neighborhood forms a square window (also known as kernel)
around the central pixel
(Moore neighborhood). Users can set the \code{window_size}
parameter to adjust the size of the kernel window.
The image is conceptually mirrored at the edges so that neighborhood
including a pixel outside the image is equivalent to take the
'mirrored' pixel inside the edge.
\code{sits_apply()} applies a function to the kernel and its result
is assigned to a corresponding central pixel on a new matrix.
The kernel slides throughout the input image and this process
generates an entire new matrix, which is returned as a new band
to the cube. The kernel functions ignores any \code{NA} values
inside the kernel window. If all pixels in the window are \code{NA}
the result will be \code{NA}.

By default, the indexes generated by \code{sits_apply()} function are
normalized between -1 and 1, scaled by a factor of 0.0001.
Normalized indexes are saved as INT2S (Integer with sign).
If the \code{normalized} parameter is FALSE, no scaling factor will be
applied and the index will be saved as FLT4S (signed float) and
the values will vary between -3.4e+38 and 3.4e+38.
}
\section{Kernel functions available}{

\itemize{
\item{\code{w_median()}: returns the median of the neighborhood's values.}
\item{\code{w_sum()}: returns the sum of the neighborhood's values.}
\item{\code{w_mean()}: returns the mean of the neighborhood's values.}
\item{\code{w_sd()}: returns the standard deviation of the neighborhood's
  values.}
\item{\code{w_min()}: returns the minimum of the neighborhood's values.}
\item{\code{w_max()}: returns the maximum of the neighborhood's values.}
\item{\code{w_var()}: returns the variance of the neighborhood's values.}
\item{\code{w_modal()}: returns the modal of the neighborhood's values.}
}
}

\examples{
if (sits_run_examples()) {
    # get a time series
    # Apply a normalization function

    point2 <-
        sits_select(point_mt_6bands, "NDVI") |>
        sits_apply(NDVI_norm = (NDVI - min(NDVI)) / (max(NDVI) - min(NDVI)))

    # Example of generation texture band with variance
    # Create a data cube from local files
    data_dir <- system.file("extdata/raster/mod13q1", package = "sits")
    cube <- sits_cube(
        source = "BDC",
        collection = "MOD13Q1-6.1",
        data_dir = data_dir
    )

    # Generate a texture images with variance in NDVI images
    cube_texture <- sits_apply(
        data = cube,
        NDVITEXTURE = w_median(NDVI),
        window_size = 5,
        output_dir = tempdir()
    )
}
}
\author{
Rolf Simoes, \email{rolfsimoes@gmail.com}

Felipe Carvalho, \email{felipe.carvalho@inpe.br}

Gilberto Camara, \email{gilberto.camara@inpe.br}
}
